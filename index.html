<!doctype html>
<html lang="my">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rome</title>
<style>
body {
  margin: 0;
  padding: 28px;
  font-family: 'Orbitron', sans-serif;
  background: radial-gradient(circle at top left, #1c1c2e, #0b0b1a);
  color: #f0f8ff;
}
.container { max-width: 1100px; margin: 0 auto; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
.header h1 { font-size: 28px; color: #b9f2ff; text-shadow: 0 0 6px #b9f2ff,0 0 12px #ffffff; }
.total { font-size: 24px; font-weight: bold; color: #ffd700; text-shadow: 0 0 6px #ffd700,0 0 12px #fff; }
.card, .bulk-input-card, .remaining-card {
  background: rgba(255,255,255,0.05);
  padding:20px;
  border-radius:16px;
  margin-bottom:20px;
  border:1px solid rgba(255,255,255,0.2);
  box-shadow:0 8px 32px rgba(0,0,0,0.2);
  backdrop-filter: blur(8px);
}
label { display:block; font-size:12px; color:#c0c0c0; margin-bottom:6px; }
textarea,input { width:100%; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.03); color:#f0f8ff; font-size:14px; box-sizing:border-box; outline:none; }
button { background: linear-gradient(135deg,#b9f2ff,#ffd700); border:none; padding:10px 16px; border-radius:12px; color:#0b0b1a; font-weight:bold; font-size:14px; cursor:pointer; text-shadow:0 0 2px #fff; transition: all 0.2s ease; }
button:hover { transform:scale(1.05); box-shadow:0 0 12px #b9f2ff,0 0 24px #ffd700; }
button.ghost { background:transparent; border:1px solid rgba(255,255,255,0.2); color:#c0c0c0; }
button.small { padding:6px 12px; font-size:13px; }
.ledger-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 12px; margin-bottom: 20px; max-height: 400px; overflow-y: auto; padding: 8px; border-radius: 12px; background: rgba(255,255,255,0.03); }
.grid-item { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 12px 8px; text-align: center; border:1px solid rgba(255,255,255,0.2); box-shadow:0 0 8px rgba(255,255,255,0.1); transition: transform 0.3s, box-shadow 0.3s; cursor: pointer;}
.grid-item:hover { transform: scale(1.05); box-shadow: 0 0 12px #b9f2ff, 0 0 24px #ffd700; }
.grid-number { font-size:18px; font-weight:bold; margin-bottom:4px; color:#b9f2ff; text-shadow:0 0 6px #ffffff; }
.grid-amount { font-size:14px; color:#ffd700; }
.bulk-input-card { display: none; }
.remaining-box { white-space: pre-wrap; max-height:200px; overflow:auto; padding:12px; border-radius:12px; background:rgba(255,255,255,0.03); font-family:monospace; font-size:13px; line-height:1.4; margin-top:10px; border:1px solid rgba(255,255,255,0.2); color:#f0f8ff; }
.stats { margin-top:10px; font-size:13px; color:#c0c0c0; }
.stats strong { color:#ffd700; }
.method-note { 
  background: rgba(255,215,0,0.1); 
  border-left: 3px solid #ffd700; 
  padding: 10px; 
  margin: 10px 0; 
  border-radius: 8px;
  font-size: 13px;
}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>Rome</h1>
    <div class="total">Total <span id="total-amount">0</span></div>
  </div>
  
  <!-- Bulk input box hidden initially -->
  <div id="bulk-card" class="card bulk-input-card">
    <label>Bulk Input (input)</label>
    
    <textarea id="bulk-input" rows="6" placeholder="please input right format"></textarea>
    <div style="margin-top:10px; display:flex; gap:8px;">
      <button id="btn-clear-input" class="ghost">Clear Input</button>
    </div>
  </div>
  
  <div class="card">
    <div id="ledger-grid" class="ledger-grid"></div>
    <div style="display:flex; gap:8px; align-items:center;">
      <button id="btn-copy" class="small">Copy Ledger</button>
      <button id="btn-clear" class="small ghost">Clear All</button>
      <button id="btn-toggle-bulk" class="small">Add Ledger</button>
    </div>
    <div class="stats">
      Entries: <span id="stat-count">0</span> — Total Amount: <strong id="stat-sum">0</strong>
    </div>
  </div>
  
  <div class="card remaining-card">
    <label id="remaining-label">Remaining (000–999 not in ledger)</label>
    <div style="display:flex; gap:8px; margin-bottom:10px;">
      <button id="btn-show-remaining" class="small">Show Remaining</button>
      <button id="btn-copy-remaining" class="small ghost">Copy Remaining</button>
    </div>
    <div id="remaining-box" class="remaining-box">(press "Show Remaining")</div>
  </div>
  
  <footer style="margin-top:24px; text-align:center; color:#c0c0c0; font-size:13px;">
    design by rome
  </footer>
</div>

<script>
(() => {
  const pad3 = n => (''+n).padStart(3,'0');
  let ledger = new Map();
  let isRemainingShown = false;

  const ledgerGrid = document.getElementById('ledger-grid');
  const statCount = document.getElementById('stat-count');
  const statSum = document.getElementById('stat-sum');
  const totalAmount = document.getElementById('total-amount');
  const remainingBox = document.getElementById('remaining-box');
  const remainingLabel = document.getElementById('remaining-label');
  const bulkCard = document.getElementById('bulk-card');
  const bulkToggleBtn = document.getElementById('btn-toggle-bulk');

  // Load ledger from localStorage
  const saved = localStorage.getItem('romeLedger');
  if(saved){
    const obj = JSON.parse(saved);
    ledger = new Map(Object.entries(obj).map(([k,v])=>[parseInt(k),v]));
  }

  function saveLedger(){ localStorage.setItem('romeLedger', JSON.stringify(Object.fromEntries(ledger))); }

  function updateLedger(){
    ledgerGrid.innerHTML = '';
    let total = 0;
    // Sort by bet amount descending (largest first)
    const sorted = [...ledger].sort((a,b)=>b[1] - a[1]);
    for(const [num, amt] of sorted){
      total += amt;
      const div = document.createElement('div');
      div.className='grid-item';
      div.innerHTML=`<div class="grid-number">${pad3(num)}</div><div class="grid-amount">${amt}</div>`;
      ledgerGrid.appendChild(div);
    }
    statCount.textContent = ledger.size;
    statSum.textContent = total;
    totalAmount.textContent = total;
    saveLedger();
  }

  function permute3(numStr){
    const arr=numStr.split(''); const set=new Set();
    const f=(a,l,r)=>{if(l===r){set.add(a.join('')); return;} for(let i=l;i<=r;i++){[a[l],a[i]]=[a[i],a[l]]; f(a,l+1,r); [a[l],a[i]]=[a[i],a[l]];}};
    f(arr,0,arr.length-1);
    return [...set].map(s=>parseInt(s,10));
  }

  function computeRemaining(){
    const rem=[]; for(let i=0;i<1000;i++){ if(!ledger.has(i)) rem.push(pad3(i)); }
    return rem;
  }

  // Helper function to split numbers by multiple separators
  function splitNumbers(input) {
    return input.split(/[.,\/\s]+/).map(n => n.trim()).filter(n => /^\d{1,3}$/.test(n));
  }

  // NEW: Process range notation
  function processRange(line) {
    // Pattern for range: 640 to 649 =500 or 640 to 649 r500
    const rangeMatch = line.match(/^(\d{3})\s+to\s+(\d{3})\s*([=r])(\d+)$/i);
    if (!rangeMatch) return null;
    
    const start = parseInt(rangeMatch[1]);
    const end = parseInt(rangeMatch[2]);
    const method = rangeMatch[3].toLowerCase();
    const amount = parseInt(rangeMatch[4]);
    
    if (start > end || start < 0 || end > 999) return null;
    
    return {
      start,
      end,
      method,
      amount,
      type: 'range'
    };
  }

  // Toggle Bulk Input
  bulkToggleBtn.addEventListener('click', ()=>{
    if(bulkCard.style.display==='none' || bulkCard.style.display===''){
      bulkCard.style.display='block';
      bulkToggleBtn.textContent='Hide Input';
    } else {
      bulkCard.style.display='none';
      bulkToggleBtn.textContent='Add Ledger';
    }
  });

  // Clear Input
  document.getElementById('btn-clear-input').addEventListener('click', ()=>{
    if(!confirm('Clear input textarea?')) return;
    document.getElementById('bulk-input').value = '';
  });

  // Copy Ledger
  document.getElementById('btn-copy').addEventListener('click', async ()=>{
    if(ledger.size===0){alert('Ledger empty'); return;}
    const lines=[...ledger].map(([n,a])=>pad3(n)+' '+a).join('\n');
    await navigator.clipboard.writeText(lines); alert('Copied ledger');
  });

  // Clear Ledger
  document.getElementById('btn-clear').addEventListener('click', ()=>{
    if(!confirm('Clear all ledger and reset app?')) return;
    ledger.clear();
    localStorage.removeItem('romeLedger');
    remainingBox.textContent='(press "Show Remaining")';
    remainingLabel.textContent='Remaining (000–999 not in ledger)';
    document.getElementById('btn-show-remaining').textContent = 'Show Remaining';
    isRemainingShown = false;
    updateLedger();
  });

  // Show/Hide Remaining
  document.getElementById('btn-show-remaining').addEventListener('click', ()=>{
    const btn = document.getElementById('btn-show-remaining');
    const remainingBox = document.getElementById('remaining-box');
    const remainingLabel = document.getElementById('remaining-label');
    
    if (!isRemainingShown) {
      // Show remaining
      const rem = computeRemaining();
      remainingLabel.textContent = `Remaining (${rem.length} numbers)`;
      let out=[];
      for(let i=0;i<rem.length;i+=10) out.push(rem.slice(i,i+10).join('  '));
      remainingBox.textContent=out.join('\n');
      btn.textContent = 'Hide Remaining';
      isRemainingShown = true;
    } else {
      // Hide remaining
      remainingBox.textContent = '(press "Show Remaining")';
      remainingLabel.textContent = 'Remaining (000–999 not in ledger)';
      btn.textContent = 'Show Remaining';
      isRemainingShown = false;
    }
  });

  // Copy Remaining
  document.getElementById('btn-copy-remaining').addEventListener('click', async ()=>{
    const text = remainingBox.textContent.trim();
    if(!text||text==='(press "Show Remaining")'){alert('No remaining'); return;}
    await navigator.clipboard.writeText(text); alert('Remaining copied');
  });

  // Handle Bulk Add Ledger
  const bulkAddBtn = document.createElement('button');
  bulkAddBtn.textContent='Submit Ledger';
  bulkAddBtn.className='small';
  bulkAddBtn.style.marginTop='10px';
  bulkCard.appendChild(bulkAddBtn);

  bulkAddBtn.addEventListener('click', ()=>{
    const text = document.getElementById('bulk-input').value;
    if(!text.trim()){alert('No input'); return;}
    
    const lines = text.split('\n').map(l=>l.trim()).filter(l=>l);
    let allLinesMethod = null;
    let allLinesAmount = null;
    
    // Check for ALL LINES method in the last line
    if (lines.length > 0) {
      const lastLine = lines[lines.length - 1];
      
      // Check if last line is a range
      const rangeInfo = processRange(lastLine);
      if (rangeInfo) {
        // Process the range directly
        for (let num = rangeInfo.start; num <= rangeInfo.end; num++) {
          if (rangeInfo.method === 'r') {
            // R method for each number in range
            const perms = permute3(pad3(num));
            perms.forEach(permNum => {
              ledger.has(permNum) ? ledger.set(permNum, ledger.get(permNum) + rangeInfo.amount) : ledger.set(permNum, rangeInfo.amount);
            });
          } else {
            // = method for each number in range
            ledger.has(num) ? ledger.set(num, ledger.get(num) + rangeInfo.amount) : ledger.set(num, rangeInfo.amount);
          }
        }
        
        // Remove the processed range line
        lines.pop();
      } else {
        // Original ALL LINES logic
        const matchR = lastLine.match(/R(\d+)$/i);
        const matchEq = lastLine.match(/=(\d+)$/);
        
        if (matchR || matchEq) {
          const beforeMethod = matchR ? 
            lastLine.slice(0, -matchR[0].length).trim() : 
            lastLine.slice(0, -matchEq[0].length).trim();
          
          if (beforeMethod) {
            if (matchR) {
              allLinesMethod = 'R';
              allLinesAmount = parseInt(matchR[1], 10);
            } else {
              allLinesMethod = '=';
              allLinesAmount = parseInt(matchEq[1], 10);
            }
            lines[lines.length - 1] = beforeMethod;
          } else {
            if (matchR) {
              allLinesMethod = 'R';
              allLinesAmount = parseInt(matchR[1], 10);
            } else {
              allLinesMethod = '=';
              allLinesAmount = parseInt(matchEq[1], 10);
            }
            lines.pop();
          }
        }
      }
    }
    
    if (allLinesMethod) {
      // Process ALL LINES with the same method
      lines.forEach(line => {
        // Check if this line is a range
        const rangeInfo = processRange(line);
        if (rangeInfo) {
          for (let num = rangeInfo.start; num <= rangeInfo.end; num++) {
            if (allLinesMethod === 'R') {
              const perms = permute3(pad3(num));
              perms.forEach(permNum => {
                ledger.has(permNum) ? ledger.set(permNum, ledger.get(permNum) + allLinesAmount) : ledger.set(permNum, allLinesAmount);
              });
            } else {
              ledger.has(num) ? ledger.set(num, ledger.get(num) + allLinesAmount) : ledger.set(num, allLinesAmount);
            }
          }
        } else {
          // Original non-range logic
          const nums = splitNumbers(line);
          nums.forEach(n => {
            if (allLinesMethod === 'R') {
              const numsToAdd = permute3(n);
              numsToAdd.forEach(nn => {
                ledger.has(nn) ? ledger.set(nn, ledger.get(nn) + allLinesAmount) : ledger.set(nn, allLinesAmount);
              });
            } else {
              const nn = parseInt(n, 10);
              ledger.has(nn) ? ledger.set(nn, ledger.get(nn) + allLinesAmount) : ledger.set(nn, allLinesAmount);
            }
          });
        }
      });
    } else {
      // Process line by line
      lines.forEach(line => {
        // Check if this line is a range
        const rangeInfo = processRange(line);
        if (rangeInfo) {
          // Process range
          for (let num = rangeInfo.start; num <= rangeInfo.end; num++) {
            if (rangeInfo.method === 'r') {
              const perms = permute3(pad3(num));
              perms.forEach(permNum => {
                ledger.has(permNum) ? ledger.set(permNum, ledger.get(permNum) + rangeInfo.amount) : ledger.set(permNum, rangeInfo.amount);
              });
            } else {
              ledger.has(num) ? ledger.set(num, ledger.get(num) + rangeInfo.amount) : ledger.set(num, rangeInfo.amount);
            }
          }
        } else {
          // Original non-range logic
          let amt = 10, isR = false;
          const matchR = line.match(/R(\d+)$/i);
          const matchEq = line.match(/=(\d+)$/);
          let numsPart = line;
          
          if (matchR) {
            amt = parseInt(matchR[1], 10);
            numsPart = line.slice(0, -matchR[0].length);
            isR = true;
          } else if (matchEq) {
            amt = parseInt(matchEq[1], 10);
            numsPart = line.slice(0, -matchEq[0].length);
          }
          
          const nums = splitNumbers(numsPart);
          
          nums.forEach(n => {
            let numsToAdd;
            if (isR) {
              numsToAdd = permute3(n);
            } else {
              numsToAdd = [parseInt(n, 10)];
            }
            
            numsToAdd.forEach(nn => {
              ledger.has(nn) ? ledger.set(nn, ledger.get(nn) + amt) : ledger.set(nn, amt);
            });
          });
        }
      });
    }
    
    updateLedger();
    alert('Added to ledger');
    bulkCard.style.display='none';
    bulkToggleBtn.textContent='Add Ledger';
    document.getElementById('bulk-input').value='';
    
    // Reset remaining display if it was shown
    if (isRemainingShown) {
      document.getElementById('remaining-box').textContent = '(press "Show Remaining")';
      document.getElementById('remaining-label').textContent = 'Remaining (000–999 not in ledger)';
      document.getElementById('btn-show-remaining').textContent = 'Show Remaining';
      isRemainingShown = false;
    }
  });

  updateLedger();
})();
</script>
</body>
</html>
